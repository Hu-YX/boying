# 用户模块

## 注册

+ 校验验证码
+ 用户名,手机号是否唯一
+ 删除该验证码,防止重复使用
+ 往常用联系人表中增加该用户信息

## 账号密码登录

+ 首先从缓存中通过`username`获取用户信息

+ 获取不到则查询数据库，并且将查到的存入缓存中（数据库也没有则报错给前端）

+ 将用户输入的密码与数据库查到的`user`对比（密码错误则报错给前端）

+ 在服务器内存中存储了该用户信息，返回`token`给前端

	

## 手机号密码登录

+ 首先从缓存中通过`telephone`获取用户信息
+ 获取不到则查询数据库，并且将查到的存入缓存中（数据库也没有则报错给前端）
+ 将用户输入的密码与数据库查到的`user`对比（密码错误则报错给前端）
+ 在服务器内存中存储了该用户信息，返回`token`给前端

## 手机号验证码登录

+ 首先校验验证码
+ 从缓存中通过`telephone`获取用户信息
+ 获取不到则查询数据库，并且将查到的存入缓存中
+ 在服务器内存中存储了该用户信息，返回`token`给前端

## 修改密码

+ 查询该手机号是否存在
+ 校验验证码
+ 删除该验证码,防止重复使用
+ 更新成功时删除无效缓存(删除两条,分别是{username:user},{telephone:user})

## 更新个人信息

+ 参数都是可选的参数
+ 更新成功时删除无效缓存

## 获取个人信息

没登录时会报错,否则返回当前登录用户的信息

## 获取验证码

+ 查询生成6位随机数
+ 用`redis`存储手机号,验证码,90秒过期
+ 用阿里云服务向手机号发送验证码

## 刷新token

+ 如果`token`过期或者在30分钟之内刚刷新过，则不进行操作
+ 否则通过原先的`token`的用户信息和当前的时间新生成一个`token`

# 常用联系人模块

## 添加常用联系人

+ 传入的是封装实体类FrequentParam
+ 设置常用联系人的用户id为当前用户id

## 删除常用联系人

+ 根据ID删除常用联系人
+ 而且要校验要删除的ID是否属于本人的常用联系人

## 修改常用联系人

+ 传入的是要修改常用联系人的id,封装实体类FrequentParam
+ 校验要修改的信息是否存在
+ 设置常用联系人的用户为当前用户,id为要修改的id
+ 根据`updateByPrimaryKeySelective`进行更新

## 显示所有常用联系人

+ 显示当前用户的所有常用联系人

## 获取常用联系人详情

+ 根据常用联系人ID以及当前用户Id获取该常用联系人详情
+ 查询不到则返回当前用户无此常用联系人

## 设置为默认常用联系人

+ 传入id
+ 通过获取常用联系人详情方法,首先判断该常用联系人合法

## 获取默认常用联系人

+ 程序当前用户的default_frequent字段，如果为null，则返回空
+ 否则根据查到的ID获取常用联系人详情



# 收货地址模块

## 添加收货地址

+ 传入的是封装实体类AddressParam
+ 设置收货地址的用户id为当前用户id

## 删除收货地址

+ 根据ID删除收货地址
+ 而且要校验要删除的ID是否属于本人的收货地址

## 修改收货地址

+ 传入的是要修改收货地址的id,封装实体类AddressParam
+ 校验要修改的信息是否存在
+ 设置收货地址的用户为当前用户,id为要修改的id
+ 根据`updateByPrimaryKeySelective`进行更新

## 显示所有收货地址

+ 显示当前用户的所有收货地址

## 获取收货地址详情

+ 根据常用联系人ID以及当前用户Id获取该收货地址详情
+ 查询不到则返回当前用户无此收货地址

## 设置为默认收货地址

+ 传入id
+ 通过获取收货地址详情方法,首先判断该收货地址合法

## 获取默认收货地址

+ 程序当前用户的default_frequent字段，如果为null，则返回空
+ 否则根据查到的ID获取收货地址详情

# 菜单模块

## 查看所有一级菜单

+ 传入parentId=0
+ 筛选出显示的(weight!=0)
+ 根据权重降序排列返回



## 查看某一级菜单的二级菜单

+ 传入某一级菜单的parentId
+ 筛选出显示的(weight!=0)
+ 根据权重降序排列返回该一级菜单的二级菜单

## 获取以Map结构获取所有商品分类

+ 先查看所有一级菜单
+ 再对上述结果查看对应该一级菜单的二级菜单
+ 存入Map中并返回
+ 作用是可以让前端获取一次目录信息即可

# 演出模块

## 演出的综合搜索筛选


* 可根据以下的几种综合搜索演出:
* 关键词,城市,目录,时间
* 调用分页工具对返回结果进行分页:每页条数,分页数
* 搜索排序方式(0->按相关度；1->按推荐；2->按时间；3->最低价格从低到高；4->最低价格从高到低)

## 获取某个演出详情

+ 通过演出ID获取该演出信息,用于在进入特定的演出详情页面

# 演出场次模块

## 获取某演唱会的所有场次

+ 根据showId获取该演出的所有场次

## 获取演出场次详情

+ 根据演出场次ID获取演出场次详情

# 演出座次模块

## 获取某演唱会场次的所有座次

+ 根据showSessionId获取该演出场次的所有座次

## 获取演出座次详情

+ 根据演出座次ID获取演出座次详情


# 订单模块

## 用户下单

一个用户对一个场次只能下单1次，但是可以选择不同座次的票，一个订单只用写一个常用联系人就行，而且限购5张

+ 前台要判断是否满5张票，增加体验
+ 传入参数:观影人，场次ID ，座次ID(集合，每张票传一个)
+ 下单人为当前用户
+ 后台先查询order中（user_id,session_id)，即该场次是否下过单，下过就报错
+ 生成订单
+ 将信息写入票中（order_id,class_id），并且对票生成对应的二维码与信息
+ 订单状态为未评价

## 查看所有订单

+ 先查询当前用户,再根据用户Id查询订单表
+ 可分类查询,共两类: 待评价,已完成
+ 支持订单名称（即演唱会名）模糊搜索，（支持对一个演唱会下几次单）
+ 支持分页查询

## 查看订单详情

+ 传入订单Id,获取当前用户,校验是否是该用户的订单
+ 返回订单本身的信息再查询出写的常用联系人详情
+ 再查询票的详情，一起返回，约定前后端格式

## 删除订单

+ 仅仅是用户层面的删除订单,即对用户隐藏

+ 传入订单Id,获取当前用户,校验是否是该用户的订单

+ 将该Id的user_delete设为true

# 票模块

## 增加票

## 查看所有票

## 查看某张票



# 评价模块

## 增加评价

+ 入口是对某个订单评价,订单找到对应的场次,在找到对应的showId
+ 或者是直接搜索演出,进入演出详情下的评论处
+ 如果订单状态为已评价，那就只能查看自己的评价（在评价表中userId,showId为特定的)，并且在自己的评价下追评（不同在于，一个直接在页面展示，一个在下一个层级）
+ 获取当前用户,判断是否有该演出的订单
+ 写下评价(评分,内容)
+ 传入当前用户姓名,头像,评分,内容,时间(当前时间),点赞数(0),举报数(0),parentId(0)
+ 将订单状态变为已完成

## 查看所有评价

+ 姓名,头像,评分,内容,时间,点赞数,举报数,只查看独立的评论(即parentId=0)
+ 支持排序,如时间,最热,好评,中评,差评
+ 支持分页查询

## 查看某评价

+ 传入parentId
+ 返回：姓名,头像,评分,内容,时间,点赞数,举报数

## 删除评价

+ 支持删除自己的评价,但是只能把评价内容删除



## 查看评论的子评论

+ 查看parentId=该父评论的所有子评论
+ 姓名,头像,评分,内容,时间,点赞数,举报数
+ 支持分页查询
+ 先展示几条点赞最高的评论,后面按照时间降序展示

## 对评论进行追加评论

+ 获取当前用户
+ 获取当前用户是否有该演出的订单
+ 写下评价(评分,内容)
+ 传入当前用户姓名,头像,评分,内容,时间(当前时间),点赞数(0),举报数(0),parentId(评论Id)
+ 把评论Id变为null，避免私自篡改ID

## 对评论进行点赞,举报

+ 获取当前用户
+ 传入评论Id,模式(0代表点赞,1代表举报)
+ 判断模式,对相关评论点赞或者举报进行+1





# 一些简化

## 订单流程简化

+ 没有购物车,订单也没有待付款的操作,用户选好票后直接付款就生成了订单。
+ 没有线下寄件的操作，用户订单生成后直接也只能可以查看电子票。
+ 生成订单后不支持退款操作。
+ 订单只有待评价，已完成两种情况。
+ 对于演出的评价，尽管演出还未开始，也可以进行评价，评价后将订单状态变为已完成